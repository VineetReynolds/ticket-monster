= Building The User UI Using HTML5
:Author: Marius Bogoevici
:thumbnail: http://static.jboss.org/ffe/1/www/origin/ticket-monster-splash-2.png

== What Will You Learn Here?


We've just implemented the business services of our application, and exposed them through RESTful endpoints. Now we need to implement a flexible user interface that can be easily used with both desktop and mobile clients. After reading this tutorial, you will understand our front-end design and the choices that we made in its implementation. Topics covered include:

* Creating single-page applications using HTML5, JavaScript and JSON
* Using JavaScript frameworks for invoking RESTful endpoints and manipulating page content
* Feature and device detection
* Implementing a version of the user interface that is works for desktop and mobile clients using JavaScript frameworks such as AngularJS

The tutorial will show you how to perform all these steps in JBoss Developer Studio, including screenshots that guide you through.

== First, the basics


In this tutorial, we will build a single-page application. All the necessary code: HTML, CSS and JavaScript is retrieved within a single page load. Rather than refreshing the page every time the user changes a view, the content of the page will be redrawn by manipulating the DOM in JavaScript. The application uses REST calls to retrieve data from the server.

[[single-page-app_image]]
.Single page application
image::gfx/single-page-app.png[]

=== Client-side MVC Support


Because this is a moderately complex example, which involves multiple views and different types of data, we will use a client-side MVC framework to structure the application, which provides amongst others:

* routing support within the single page application;
* event-driven interaction between views and data;
* simplified CRUD invocations on RESTful services.

In this application we use the AngularJS framework.

[[use-of-backbone_image]]
.Backbone architecture
image::gfx/backbone-usage.png[]

=== Modularity


In order to provide good separation of concerns, we split the JavaScript code into modules.  Ensuring that all the modules of the application are loaded properly at runtime becomes a complex task, as the application size increases. To conquer this complexity, we use the Asynchronous Module Definition mechanism as implemented by the "require.js" library.

[TIP]
.Asynchronous Module Definition
========================================================================
The Asynchronous Module Definition (AMD) API specifies a mechanism for defining modules such that the module, and its dependencies, can be asynchronously loaded. This is particularly well suited for the browser where synchronous loading of modules incurs performance, usability, debugging, and cross-domain access problems.
========================================================================

=== Templating


Instead of manipulating the DOM directly, and mixing up HTML with the JavaScript code, we create HTML markup fragments separately as templates which are applied when the application views are rendered.

In this application we use the templating support provided by AngularJS.

=== Mobile and desktop versions


The page flow and structure, as well as feature set, are slightly different for mobile and desktop, and therefore we will build two variants of the single-page-application, one for desktop and one for mobile. As the application variants are very similar, we will cover the desktop version of the application first, and then we will explain what is different in the mobile version.

== Setting up the structure


Before we start developing the user interface, we need to set up the general application structure and add the JavaScript libraries. First, we create the directory structure:

[[ui-directory-structure]]
.File structure for our web application
image::gfx/ui-file-structure.png[]

We put stylesheets in `resources/css` folder and images in `resources/img`. `resources/js` contains the JavaScript code, split between `resources/js/libs` - which contains the libraries used by the application, `resources/js/app` - which contains the application code and AngularJS partials, and `resources/js/configurations` which contains module definitions for the different versions of the application - i.e. mobile and desktop. The `resources/js/app` folder will contain the application modules, in subsequent subdirectories, for controllers, directives, and views.

The first step in implementing our solution is adding the stylesheets and JavaScript libraries to the `resources/css` and `resources/js/libs`:

require.js::
    AMD support
jQuery::
    general purpose library for HTML traversal and manipulation
Underscore::
    JavaScript utility library
AngularJS::
    Client-side MVC framework
Bootstrap::
    UI components and stylesheets for page structuring
Modernizr::
    JavaScript library for HTML5 and CSS3 feature detection
    

You can copy these libraries (with associated stylesheets) from the project sources. You can also copy the CSS stylesheet in `screen.css`, since we'll include this stylesheet in the HTML. Addtionally, copy the images from the `src/main/webapp/resources/img` directory in the project sources to the equivalent one in your workspace.

Now, we create the main page of the application (which is the URL loaded by the browser):

.src/main/webapp/index.html
[source,html]
-------------------------------------------------------------------------------------------------------
<!DOCTYPE html>
<html>
<head>
    <title>Ticket Monster</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=0"/>

    <script type="text/javascript" src="resources/js/libs/modernizr-2.8.3.min.js"></script>
    <script type="text/javascript" src="resources/js/libs/require.js"
            data-main="resources/js/configurations/loader"></script>
</head>
<body>
</body>
</html>
-------------------------------------------------------------------------------------------------------

As you can see, the page does not contain much. It loads Modernizr (for HTML5 and CSS3 feature detection) and RequireJS (for loading JavaScript modules in an asynchronous manner). Once RequireJS is loaded by the browser, it will configure itself to use a `baseUrl` of `resources/js/configurations` (specified via the `data-main` attribute on the `script` tag). All scripts loaded by RequireJS will use this `baseUrl` unless specified otherwise.

RequireJS will then load a script having a module ID of `loader` (again, specified via the `data-main` attribute):

.src/main/webapp/resources/js/configurations/loader.js
[source,javascript]
-------------------------------------------------------------------------------------------------------
//detect the appropriate module to load
define(function () {

    /*
     A simple check on the client. For touch devices or small-resolution screens)
     show the mobile client. By enabling the mobile client on a small-resolution screen
     we allow for testing outside a mobile device (like for example the Mobile Browser
     simulator in JBoss Tools and JBoss Developer Studio).
     */

    var environment;

    if (Modernizr.touch || Modernizr.mq("only all and (max-width: 480px)")) {
        environment = "mobile"
    } else {
        environment = "desktop"
    }

    require([environment]);
});
-------------------------------------------------------------------------------------------------------

This script detects the current client (mobile or desktop) based on its capabilities (touch or not) and loads another JavaScript module (`desktop` or `mobile`) defined in the `resources/js/configurations` folder (aka the `baseUrl`) depending on the detected features. In the case of the desktop client, the code is loaded from `resources/js/configurations/desktop.js`.

.src/main/webapp/resources/js/configurations/desktop.js
[source,javascript]
-------------------------------------------------------------------------------------------------------
/**
 * Shortcut alias definitions - will come in handy when declaring dependencies
 * Also, they allow you to keep the code free of any knowledge about library
 * locations and versions
 */
requirejs.config({
    baseUrl: "resources/js",
    paths: {
        jquery:'libs/jquery-2.1.1',
        underscore:'libs/underscore',
        text:'libs/text',
        bootstrap: 'libs/bootstrap',
        angular: 'libs/angular',
        angularRoute: 'libs/angular-route',
        angularResource: 'libs/angular-resource',
        aggregator: 'app/aggregator/desktop'
    },
    // We shim Angular and Underscore.js since they don't declare AMD modules
    shim: {
        'angular': {'exports' : 'angular'},

        'angularRoute': {
        	deps: ['angular']
        },

        'angularResource': {
            deps: ['angular']
        },

        'underscore': {
            exports: '_'
        }
    },
    priority: [
        "angular"
    ]
});

// Now we declare all the dependencies
// This loads and runs the 'initializer' and 'aggregator' modules.
require([
        'jquery',
        'angular',
        'aggregator'
    ], function($, angular, app) {
        // Configure jQuery to append timestamps to requests, to bypass browser caches
        // Important for MSIE
        $.ajaxSetup({cache:false});
        $('head').append('<link rel="stylesheet" href="resources/css/bootstrap.css" type="text/css" media="all"/>');
        $('head').append('<link rel="stylesheet" href="resources/css/bootstrap-theme.css" type="text/css" media="all"/>');
        $('head').append('<link rel="stylesheet" href="resources/css/screen.css" type="text/css" media="all"/>');
        $('head').append('<link href="http://fonts.googleapis.com/css?family=Rokkitt" rel="stylesheet" type="text/css">');

        $.ajax({
            url:'resources/js/app/aggregator/main.html',
            type: "GET",
            success: function(data) {
                $('body').append(data);
                angular.element().ready(function() {
                    // bootstrap the app manually
                    angular.bootstrap(document, ['ticketMonster']);
                });
            }
        });
    }
);

define("configuration", {
    baseUrl : ""
});
-------------------------------------------------------------------------------------------------------

The module loads all the utility libraries, converting them to AMD modules where necessary (like it is the case for Angular and Underscore). It also defines a separate module - the `configuration` module that allows customizing the REST service URLs (this will become in handy in a further tutorial). Finally, it loads the dependent modules - `jquery`, `bootstrap` and `aggregator`.

Before we add any functionality, let us create a first landing page. This page is loaded in the above snippet before bootstrapping the `aggregator` module in AngularJS:

.src/main/webapp/resources/js/app/aggregator/main.html
-------------------------------------------------------------------------------------------------------
<!--
    The main layout of the page - contains the menu and the 'content' &lt;div/&gt; in which all the
    views will render the content.
-->
<div id="logo"><div class="wrap visible-md-block visible-lg-block"><h1>Ticket Monster</h1></div></div>
<div id="container">
    <div id="menu">
        <div class="navbar">

            <a class="navbar-brand visible-xs-inline visible-sm-inline" href="#/">Ticket Monster</a>

            <!-- Toggle get grouped for better mobile display -->
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar-items">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
            </div>

            <!-- Collect the nav links, forms, and other content for toggling -->
            <div id="navbar-items" class="collapse navbar-collapse">
                <ul class="nav navbar-nav">
                    <li><a href="#about" class="hidden-xs">About</a></li>
                    <li><a data-toggle="collapse" data-target=".navbar-collapse" href="#about" class="visible-xs">About</a></li>
                    <li><a href="#events" class="hidden-xs">Events</a></li>
                    <li><a data-toggle="collapse" data-target=".navbar-collapse" href="#events" class="visible-xs">Events</a></li>
                    <li><a href="#venues" class="hidden-xs">Venues</a></li>
                    <li><a data-toggle="collapse" data-target=".navbar-collapse" href="#venues" class="visible-xs">Venues</a></li>
                    <li><a href="#bookings" class="hidden-xs">Bookings</a></li>
                    <li><a data-toggle="collapse" data-target=".navbar-collapse" href="#bookings" class="visible-xs">Bookings</a></li>
                    <li><a href="#monitor" class="hidden-xs">Monitor</a></li>
                    <li><a data-toggle="collapse" data-target=".navbar-collapse" href="#monitor" class="visible-xs">Monitor</a></li>
                    <li><a href="admin" class="hidden-xs">Administration</a></li>
                    <li><a data-toggle="collapse" data-target=".navbar-collapse" href="admin" class="visible-xs">Administration</a></li>
                </ul>
            </div>
        </div>
    </div>
    <div id="content" class="container" ng-view>
    </div>
</div>

<footer style="" class="visible-md-block visible-lg-block">
    <div style="text-align: center;"><img src="resources/img/rhjb_eap_logo.png" alt="HTML5"/></div>
</footer>
-------------------------------------------------------------------------------------------------------

TicketMonster uses AngularJS which employs MVVM principles in order to separate application logic from it's actual graphical content. The actual HTML is described in partials (AngularJS template files), which are applied by the application, when necessary, on a DOM element - effectively populating it's content. So the general content of the page, as described in the `body` element is described in a template file too.

The actual HTML code of the template contains a menu definition which will be present on all the pages, as well as an empty element named `content`, which is the placeholder for the application views. When a view is displayed, it will apply a template and populate the `content` element. Note the use of the `ng-view` AngularJS directive in the above snippet - based on the route/URL of the application, different content present in diffent partials will be populated in the view.

We will now begin by setting up a critical piece of the application, the aggregator.

=== Aggregator


The aggregator module allows us to split our application into separate AngularJS modules, and we will define it as follows:

.src/main/webapp/resources/js/app/aggregator/desktop.js
[source, javascript]
-------------------------------------------------------------------------------------------------------
'use strict';

/**
 * The main module for the desktop application.
 * Pulls in other modules.
 */
define("aggregator", [
    'angular',
    'angularRoute',
    'angularResource'
],function (angular) {

    return angular.module('ticketMonster', ['ngRoute',
        'ngResource'])
        .config(['$routeProvider', function($routeProvider) {
            $routeProvider
                .otherwise({redirectTo: '/'});
        }]);
});
-------------------------------------------------------------------------------------------------------

Remember, this is a single page application. You can either navigate using urls such as `http://localhost:8080/ticket-monster/index.html#events` or using relative urls (from within the application, this being exactly what the main menu does). The fragment after the hash sign represents the url within the single page, on which the router will act, according to the mappings set up for the `routeProvider`. In the `aggregator`, we merely setup the default route; other routes will be setup in their own modules.

[TIP]
.Organizing AngularJS modules
========================================================================
There are several ways to organize AngularJS modules in an application. In TicketMonster, we follow the approach of creating a new AngularJS module for every view or a group of related views. Displaying events is handled by one AngularJS module. Displaying event details is handled by another. And likewise, for displaying the booking form, among other views.
========================================================================


Setting up the initial views
----------------------------

Let us complete our application setup by creating the initial landing page. We'll create a new `ticketMonster.homeView` module and reference it in the `aggregator` module. The first thing that we will need to do is to add the dependencies to the aggregator:

.src/main/webapp/resources/js/app/aggregator/desktop.js
[source, javascript]
-------------------------------------------------------------------------------------------------------
'use strict';

/**
 * The main module for the desktop application.
 * Pulls in other modules.
 */
define("aggregator", [
    'angular',
    'angularRoute',
    'angularResource',
    'app/home/view'
],function (angular) {

    return angular.module('ticketMonster', ['ngRoute',
        'ngResource',
        'ticketMonster.homeView'])
        .config(['$routeProvider', function($routeProvider) {
            $routeProvider
                .otherwise({redirectTo: '/'});
        }]);
});
-------------------------------------------------------------------------------------------------------

We then add the AngularJS module:

.src/main/resources/js/app/home/view.js
[source,javascript]
-------------------------------------------------------------------------------------------------------
'use strict';
define([
    'angular',
    'angularRoute'
], function(angular) {
    angular.module('ticketMonster.homeView', ['ngRoute'])
        .config(['$routeProvider', function($routeProvider) {
            $routeProvider.when('/', {
                templateUrl: 'resources/js/app/home/home.html',
                controller: 'HomeController'
            });
        }])
        .controller('HomeController', ['$scope', function($scope) {

        }]);
});
-------------------------------------------------------------------------------------------------------

Functionally, this is a very basic AngularJS module - it configures a route for the `/` URL (our landing page). The route is bound to a partial located at `src/main/webapp/resources/js/app/home/home.html` and a corresponding AngularJS controller named `HomeController`. The view only renders the splash page of the application with no underlying logic, but it helps us introduce the concept of controllers that will be heavily used throughout the application modules. One main role of a controller is to 
describe the logic for manipulating the view and it's children. The AngularJS framework sets up the initial state of the `$scope` object, and passes it to the controller function where behavior is added to the `$scope`. In this very simple case, no modification is performed on the `$scope`, as the landing page is static content. In upcoming views, this will no longer be true.

You can proceed by copying the content of `src/main/webapp/resources/js/app/home/home.html` to your project.

Now you can navigate to `http://localhost:8080/ticket-monster` and see the results.

== Displaying Events


The first use case that we implement is event navigation. The users will be able to view the list of events and select the one that they want to attend. After doing so, they will select a venue, and will be able to choose a performance date and time.

=== The Event model

We define an AngularJS factory for interacting with event data. Nearly all domain entities (booking, event, venue) are represented by a corresponding AngularJS factory that uses the ngResource module of AngularJS. The ngResource module provided by AngularJS provides a `$resource` service that can be used to create `resource objects`. Each resource object would have action methods to perform operations like GET, PUT, POST, DELETE etc. without having to manually issue HTTP requests against the REST API URLs.

For the purpose of modularity, we'll define all such factories in a separate AngularJS module - `ticketMonster.api`. This module, as the name suggests, will define factories for creating resource objects that lets you interact with the REST APIs of the TicketMonster application. The factory `EventResource` will be used to perform actions against the Events API located at `/rest/events`. Likewise, the `VenueResource` will be used when performing actions against the Venues API located at `/rest/venues`, `ShowResource` for the Shows API, and so on.

.src/main/webapp/resources/js/app/api/services.js
[source,javascript]
-------------------------------------------------------------------------------------------------------
'use strict';
define([
    'angular',
    'underscore',
    'configuration',
    'angularResource'
], function (angular, _, config) {
    angular.module('ticketMonster.api', ['ngResource'])
        .factory('EventResource', function ($resource) {
            var resource = $resource(config.baseUrl + 'rest/events/:eventId', {eventId: '@id'}, {
                'queryAll': {
                    method: 'GET',
                    isArray: true
                }, 'query': {method: 'GET', isArray: false}, 'update': {method: 'PUT'}
            });
            return resource;
        })
        .factory('VenueResource', function ($resource) {
            var resource = $resource(config.baseUrl + 'rest/venues/:venueId', {venueId: '@id'}, {
                'queryAll': {
                    method: 'GET',
                    isArray: true
                }, 'query': {method: 'GET', isArray: false}, 'update': {method: 'PUT'}
            });
            return resource;
        })
        .factory('ShowResource', function ($resource) {
            var resource = $resource(config.baseUrl + 'rest/shows/:showId', {showId: '@id'}, {
                'queryAll': {
                    method: 'GET',
                    isArray: true
                }, 'query': {method: 'GET', isArray: false}, 'update': {method: 'PUT'}
            });
            return resource;
        })
        .factory('BookingResource', function ($resource) {
            var resource = $resource(config.baseUrl + 'rest/bookings/:bookingId', {bookingId: '@id'}, {
                'queryAll': {
                    method: 'GET',
                    isArray: true
                }, 'query': {method: 'GET', isArray: false}, 'update': {method: 'PUT'}
            });
            return resource;
        })
        .factory('PerformanceDetailsResource', function ($resource) {
            var resource = $resource(config.baseUrl + 'rest/shows/performance/:performanceId', {performanceId: '@id'}, {
                'queryAll': {
                    method: 'GET',
                    isArray: true
                }, 'query': {method: 'GET', isArray: false}, 'update': {method: 'PUT'}
            });
            return resource;
        });
});
-------------------------------------------------------------------------------------------------------

Through the resource objects, we can perform CRUD operations against the REST services we defined earlier.

[TIP]
.ngResource
========================================================================
The $resource service in the ngResource module, makes it easy to create a RESTful client with just a few lines of code.
The resource objects created by the service, also perform CRUD operations with the REST service through simple method invocations without the overhead of writing code to deal with issuing HTTP requests and parsing HTTP responses.
========================================================================

=== The EventsView view

Now that we have implemented the data components of the example, we need to create the view that displays them.

.src/main/webapp/resources/js/app/events/eventsView.js
[source,javascript]
-------------------------------------------------------------------------------------------------------
'use strict';
define([
    'angular',
    'underscore',
    'configuration',
    'bootstrap',
    'angularRoute',
    'angularResource',
    'app/api/services',
    'app/components/components'
], function(angular, _, config) {
    angular.module('ticketMonster.eventsView', ['ngRoute', 'ngResource', 'ticketMonster.api', 'ticketMonster.ui.components'])
        .config(['$routeProvider', function($routeProvider) {
            $routeProvider.when('/events', {
                templateUrl: 'resources/js/app/events/events.html',
                controller: 'EventsController'
            });
        }])
        .controller('EventsController', ['$scope','EventResource', function($scope, EventResource) {
        	$scope.config = config;
            $scope.events = EventResource.queryAll(function(data) {
                $scope.events = data;
                $scope.categories = _.uniq(
                    _.map($scope.events, function(event){
                        return event.category;
                    }), false, function(item){
                        return item.id;
                    });
                $('.carousel-inner').find('.item:first').addClass('active');
                $(".carousel").carousel();
            });
        }]);
});
-------------------------------------------------------------------------------------------------------

The module contains configuration to bind the `EventsController` controller function defined in the module, to the Angular partial located at `resources/js/app/events/events.html`. The binding is effective for the `/events` URL. When the controller is invoked on visiting the URL, the `EventResource` resource object from the `ticketMonster.api` component is utilized to query the Events REST API for all events. The list of all events is bound to the `$scope` as the `events` attribute. Additionally, a `categories` attribute is also created on the `$scope` object that contains the various event categories. Both attributes are eventually referenced in the Angular partial bound to the view. Note the dependency on the Bootstrap module - we initialize the Bootstrap carousel and popover components when this view is rendered.

.src/main/webapp/resources/js/app/events/events.html
[source,html]
-------------------------------------------------------------------------------------------------------
<div class="row">
    <div class="col-md-3 col-md-offset-1">
        <div class="panel" id="itemMenu">

            <div class="panel panel-default" ng-repeat="category in categories">
                <div class="panel-heading">
                    <a class="panel-toggle"
                       data-target="#category-{{category.id}}-collapsible" data-toggle="collapse"
                       data-parent="#itemMenu">{{category.description}}</a>
                </div>
                <div id="category-{{category.id}}-collapsible" class="panel-collapse collapse">
                    <div id="category-{{category.id}}" class="panel-body">
                        <p ng-repeat="event in events" ng-if="event.category.id == category.id">
                            <a menu-popover href="#events/{{event.id}}" rel="popover"
                              data-content="{{event.description}}"
                              data-original-title="{{event.name}}">{{event.name}}</a>
                        </p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id='itemSummary' class="col-md-8 hidden-xs">
        <div class="carousel-container">
            <div id="eventCarousel" class="carousel slide">
                <!-- Carousel items -->
                <div class="carousel-inner">
                    <div class="item" ng-repeat="event in events" ng-if="event.mediaItem" ng-class="{'active':$first}">
                        <img ng-src='{{config.baseUrl + "rest/media/" + event.mediaItem.id}}'/>

                        <div class="carousel-caption">
                            <div class="row">
                                <div class="col-md-7 col-md-offset-1">
                                    <h4>{{event.name}}</h4>
                                    <p>{{event.description}}</p>
                                </div>
                                <div class="col-md-2">
                                    <a class="btn btn-danger action" href="#events/{{event.id}}">Book tickets</a>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <!-- Carousel nav -->
                <a class="carousel-control left" href="#eventCarousel" data-slide="prev">
                    <span class="glyphicon glyphicon-chevron-left"></span>
                </a>
                <a class="carousel-control right" href="#eventCarousel" data-slide="next">
                    <span class="glyphicon glyphicon-chevron-right"></span>
                </a>
            </div>
        </div>
    </div>
</div>
-------------------------------------------------------------------------------------------------------


As well as applying the template and preparing the data that will be used to fill it in (the `categories` and `events` entries in the map), the `EventsController` method also performs the JavaScript calls that are required to initialize the UI components (in this case the Bootstrap carousel and popover).

Now that the module is in place, we need to add it to the aggregator. 

.src/main/webapp/resources/js/app/aggregator/desktop.js
[source, javascript]
-------------------------------------------------------------------------------------------------------
'use strict';

/**
 * The main module for the desktop application.
 * Pulls in other modules.
 */
define("aggregator", [
    'angular',
    'angularRoute',
    'angularResource',
    'app/home/view',
	'app/events/eventsView'
],function (angular) {

    return angular.module('ticketMonster', ['ngRoute',
        'ngResource',
		'ticketMonster.api',
        'ticketMonster.homeView',
		'ticketMonster.eventsView'])
        .config(['$routeProvider', function($routeProvider) {
            $routeProvider
                .otherwise({redirectTo: '/'});
        }]);
});
-------------------------------------------------------------------------------------------------------


== Viewing a single event


With the events list view now in place, we can add a view to display the details of each individual event, allowing the user to select a venue and performance time.

We already have the models in place so all we need to do is to create the additional module and expand the aggregator. First, we'll implement the module:

.src/main/webapp/resources/js/app/views/desktop/event-detail.js
[source,javascript]
-------------------------------------------------------------------------------------------------------
'use strict';
define([
    'angular',
    'underscore',
    'configuration',
    'bootstrap',
    'angularRoute',
    'angularResource',
    'app/api/services'
], function(angular, _, config) {
    angular.module('ticketMonster.eventDetailView', ['ngRoute', 'ngResource', 'ticketMonster.api'])
        .config(['$routeProvider', function($routeProvider) {
            $routeProvider.when('/events/:eventId', {
                templateUrl: 'resources/js/app/eventDetail/eventDetail.html',
                controller: 'EventDetailController'
            });
        }])
        .controller('EventDetailController', ['$scope', '$routeParams', '$location', 'EventResource', 'ShowResource', function($scope, $routeParams, $location, EventResource, ShowResource) {
        	$scope.config = config;
            EventResource.get({eventId:$routeParams.eventId}, function(data) {
                $scope.event = data;
                ShowResource.queryAll({event:$scope.event.id}, function(data) {
                    console.log("Fetched Shows");
                    $scope.shows = data;
                }, function() {
                    console.log("Failed to fetch shows");
                });
            }, function() {
                console.log("failure");
            });

            $scope.$watch('selectedShow', function(newValue, oldValue) {
                if(newValue == null) {
                    $scope.selectedPerformanceDays = [];
                } else {
                    $scope.selectedPerformanceDays = newValue.performances;
                    $scope.selectedPerformanceDay = $scope.selectedPerformanceDays[0];
                }
                $scope.selectedPerformances = [];
                $scope.selectedPerformance = {};
            });

            $scope.$watch('selectedPerformanceDay', function(newValue, oldValue) {
                if(newValue != null) {
                    $scope.selectedPerformances = _.filter($scope.selectedShow.performances, function(performance) {
                        var performanceDay = new Date(performance.date).setHours(0, 0, 0, 0);
                        var chosenDay = new Date(newValue.date).setHours(0, 0, 0, 0);
                        return chosenDay.valueOf() === performanceDay.valueOf();
                    });
                    $scope.selectedPerformance = $scope.selectedPerformances[0];
                }
            });

            $scope.beginBooking = function() {
                $location.path('/book/' + $scope.selectedShow.id + '/' + $scope.selectedPerformance.id);
            }
        }]);
});
-------------------------------------------------------------------------------------------------------

This view is more complex than the global events view, as portions of the page need to be updated when the user chooses a venue. This is accomplished by establishing watches using AngularJS, on select attributes on the `$scope` object. When the attribute values change, other attributes are also modified in response. For instance, when a venue is chosen, the list of performances available at the location need to be updated.

As you can see, this is very similar to the previous view and route, except that now the application can accept parameterized URLs (e.g. `http://localhost:8080/ticket-monster/index#events/1`). This URL can be entered directly into the browser, or it can be navigated to as a relative path (e.g. `#events/1`) from within the applicaton.

[[ui-event-detail]]
.On the event details page some fragments are re-rendered when the user selects a venue
image::gfx/ui-event-details.png[]

The view responds to three different events:

* changing the current venue triggers a reload of the venue details and the venue image, as well as the performance times. The application retrieves the performance times through a REST call.
* changing the day of the performance causes the performance time selector to reload.
* once the venue and performance date and time have been selected, the user can navigate to the booking page.

The corresponding partial for the view rendered is:

.src/main/webapp/resources/js/app/eventDetail/eventDetail.html
[source,html]
-------------------------------------------------------------------------------------------------------
<div class="row">
    <h2 class="page-header special-title light-font">{{event.name}}</h2>
</div>
<div class="row">
    <div class="col-md-4">
        <div class="well">
            <div class="row">
                <h3 class="page-header col-md-6">What?</h3>
                <div class="col-md-6" id='eventMedia'>
                	<img ng-if="event.mediaItem" width="100%" ng-src='{{config.baseUrl + "rest/media/" + event.mediaItem.id}}' />
                </div>
            </div>
            <div class="row top5">
                <div class="col-md-12">{{event.description}}</div>
            </div>
        </div>
    </div>
    <div class="col-md-4">
        <div class="well">
            <div class="row">
                <h3 class="page-header col-md-6">Where?</h3>
                <div class="col-md-6" id='venueMedia'>
                    <img ng-if="selectedShow.venue.mediaItem" width="100%" ng-src='{{config.baseUrl + "rest/media/" + selectedShow.venue.mediaItem.id}}' />
                </div>
            </div>
            <div class="row top5">
                <div class="col-md-12">
                    <select id="venueSelector" class="form-control" ng-options="show as (show.venue.address.city + ' : ' + show.venue.name) for show in shows" ng-model="selectedShow">
                        <option value='' selected>Select a venue</option>
                    </select>
                </div>
            </div>
            <div class="row top5">
                <div class="col-md-12">
                    <div id="eventVenueDescription" ng-if="selectedShow">
                        <address>
                            <p>{{selectedShow.venue.description}}</p>
                            <p><strong>Address:</strong></p>
                            <p>{{selectedShow.venue.address.street}}</p>
                            <p>{{selectedShow.venue.address.city}}, {{selectedShow.venue.address.country}}</p>
                        </address>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div id='bookingWhen' ng-hide="!selectedShow" class="col-md-4">
        <div class="well">
            <div class="row">
                <h3 class="page-header col-md-6">When?</h3>
            </div>

            <div class="row top5">
                <div class="col-md-12">
                    <select class="form-control" id="dayPicker" ng-options="performanceDay as (performanceDay.date | date: 'EEE dd MMMM yyyy') for performanceDay in selectedPerformanceDays" ng-model="selectedPerformanceDay" />
                </div>
            </div>
            <div class="row top5">
                <div class="col-md-12">
                    <select class="form-control" id="performanceTimes" ng-options="performance as (performance.date | date: 'shortTime') for performance in selectedPerformances" ng-model="selectedPerformance" />
                </div>
            </div>

            <div id="bookingOption" class="row top5 visible-md-block visible-lg-block">
                <div class="col-md-6">
                    <input name="bookButton" class="btn btn-primary" type="button" value="Order tickets" ng-click="beginBooking()" ng-disabled="!selectedPerformance.id" />
                </div>
            </div>
        </div>
    </div>
</div>
-------------------------------------------------------------------------------------------------------

Now that the module exists, we add it to the aggregator:

.src/main/webapp/resources/js/app/aggregator/desktop.js
[source, javascript]
-------------------------------------------------------------------------------------------------------
'use strict';

/**
 * The main module for the desktop application.
 * Pulls in other modules.
 */
define("aggregator", [
    'angular',
    'angularRoute',
    'angularResource',
    'app/home/view',
	'app/events/eventsView',
	'app/eventDetail/eventDetailView'
],function (angular) {

    return angular.module('ticketMonster', ['ngRoute',
        'ngResource',
		'ticketMonster.api',
        'ticketMonster.homeView',
		'ticketMonster.eventsView',
		'ticketMonster.eventDetailView'])
        .config(['$routeProvider', function($routeProvider) {
            $routeProvider
                .otherwise({redirectTo: '/'});
        }]);
});
-------------------------------------------------------------------------------------------------------

With this in place, all that remains is to implement the final view of this use case, creating the bookings.

== Creating Bookings


The user has chosen the event, the venue and the performance time, and must now create the booking. Users can select one of the available sections for the show's venue, and then enter the number of tickets required for each category available for this show (Adult, Child, etc.). They then add the tickets to the current order, which causes the summary view to be updated. Users can also remove tickets from the order. When the order is complete, they enter their contact information (e-mail address) and submit the order to the server.

First, we add the new view:

.src/main/webapp/resources/js/app/booking/view.js
[source,javascript]
-------------------------------------------------------------------------------------------------------
'use strict';
define([
    'angular',
    'underscore',
    'configuration',
    'angularRoute',
    'app/api/services'
], function(angular, _, config) {
    angular.module('ticketMonster.bookingView', ['ngRoute', 'ticketMonster.api'])
        .config(['$routeProvider', function($routeProvider) {
            $routeProvider
                .when('/book/:showId/:performanceId', {
                    templateUrl: 'resources/js/app/booking/booking.html',
                    controller: 'BookingController'
                });

        }])
        .directive('addTickets', function() {
            var link = function(scope, element, attributes) {

            };

            return {
                controller: "TicketsController",
                scope: false,
                link: link,
                restrict: "A",
                templateUrl: "resources/js/app/booking/add-tickets.html"
            };
        })
        .directive('checkoutBooking', function() {
            var link = function(scope, element, attributes) {

            };

            return {
                controller: "CheckoutController",
                scope: false,
                link: link,
                restrict: "A",
                templateUrl: "resources/js/app/booking/checkout-booking.html"
            };
        })
        .factory("ShoppingCart", function() {
            var cart = {};

            cart.reset = function() {
                cart.tickets = [];
                cart.totals = [];
                cart.performance = {};
                cart.updateTotals();
            };

            cart.getTotals = function() {
                return cart.totals;
            };

            cart.getPerformance = function() {
                return cart.performance;
            };

            cart.setPerformance = function(performance) {
                cart.performance = performance;
            };

            cart.updateTotals = function() {
                cart.totals = _.reduce(cart.tickets, function (totals, ticketRequest) {
                    return {
                        tickets: totals.tickets + ticketRequest.quantity,
                        price: totals.price + ticketRequest.quantity * ticketRequest.ticketPrice.price
                    };
                }, {tickets: 0, price: 0.0});
            };

            cart.addTicket = function(ticketPrice) {
                var found = false;
                _.each(cart.tickets, function (ticket) {
                    if (ticket.ticketPrice.id == ticketPrice.id) {
                        ticket.quantity += ticketPrice.quantity;
                        found = true;
                    }
                });
                if (!found) {
                    cart.tickets.push({ticketPrice:ticketPrice, quantity:ticketPrice.quantity});
                }
                cart.updateTotals();
            };

            cart.removeTicket = function(index) {
                cart.tickets.splice(index, 1);
                cart.updateTotals();
            };

            cart.isEmpty = function() {
                return (cart.totals.tickets === 0);
            };

            cart.reset();

            return cart;
        })
        .controller('BookingController', ['$scope', function($scope) {
            
        }])
        .controller('TicketsController', ['$scope', '$routeParams', '$location', 'ShoppingCart', 'ShowResource', 'BookingResource', function($scope, $routeParams, $location, ShoppingCart, ShowResource, BookingResource) {
            console.log("In Tickets View");

            $scope.show = $scope.show || {};
            $scope.performance = $scope.performance || {};
            $scope.sections = $scope.sections || [];
            $scope.ticketPrices = $scope.ticketPrices || [];

            ShowResource.query({showId:$routeParams.showId}, function(data) {
                console.log("Fetched Show");
                $scope.show = data;
                $scope.performance = _.find($scope.show.performances, function (item) {
                    return item.id == $routeParams.performanceId;
                });
                ShoppingCart.setPerformance($scope.performance);
                var id = function (item) {return item.id;};
                $scope.sections = _.uniq(_.sortBy(_.pluck($scope.show.ticketPrices, 'section'), id), true, id);
            }, function() {
                console.log("Failed to fetch shows");
            });

            $scope.$watch('selectedSection', function(newValue, oldValue) {
                if(newValue) {
                    var sectionPrices = _.filter($scope.show.ticketPrices, function(item) {
                        return item.section.id === newValue.id;
                    });
                    $scope.ticketPrices = angular.copy(sectionPrices);
                } else {
                    $scope.ticketPrices = [];
                }
            });

            $scope.checkTickets = function() {
                var sum = 0;
                _.each($scope.ticketPrices, function(ticketPrice) {
                    sum += (ticketPrice.quantity || 0);
                });
                return sum < 1;
            };

            $scope.addTickets = function() {
                _.each($scope.ticketPrices, function (ticketPrice) {
                    if (ticketPrice.quantity != undefined) {
                        ShoppingCart.addTicket(ticketPrice);
                    }
                });
                $scope.selectedSection = null;
                $scope.toggleView();
            };
        }])
        .controller('CheckoutController', ['$scope', '$routeParams', '$location', 'ShoppingCart', 'ShowResource', 'BookingResource', function($scope, $routeParams, $location, ShoppingCart, ShowResource, BookingResource) {
            console.log("In Booking View");

            $scope.performance = $scope.performance || {};
            $scope.bookingRequest = $scope.bookingRequest || {};
            $scope.tickets = ShoppingCart.tickets;
            $scope.totals = ShoppingCart.getTotals();

            $scope.$watch(function() {
                return ShoppingCart.getTotals();
            }, function(newValue, oldValue) {
                $scope.totals = newValue;
            });

            $scope.removeTicket = function(index) {
                ShoppingCart.removeTicket(index);
            };

            $scope.disableCheckout = function() {
                return !(!ShoppingCart.isEmpty()
                    && $scope.bookingRequest.email != undefined
                    && $scope.bookingRequest.email != '');
            };

            $scope.checkout = function() {
                var bookingRequest = {ticketRequests:[]};
                bookingRequest.ticketRequests = _.map(ShoppingCart.tickets, function (ticket) {
                    return {ticketPrice:ticket.ticketPrice.id, quantity:ticket.quantity}
                });
                bookingRequest.email = $scope.bookingRequest.email;
                bookingRequest.performance = ShoppingCart.getPerformance().id;
                BookingResource.save(bookingRequest, function(data) {
                    ShoppingCart.reset();
                    $location.path('/bookings/' + data.id);
                }, function() {
                    console.log("Failure");
                });
            };
        }]);
});
-------------------------------------------------------------------------------------------------------

The code above may be surprising! After all, there might have been the assumption that a single controller would be added, but instead, we added three! This view makes use of two components (the `addTickets` and `checkoutBooking` directives) for rendering parts of the main view. Each directive is bound to a separate controller - `TicketsController` for the `addTickets` directive and `CheckoutController` for the `checkoutBooking` directive. The container for both these components is bound to the main controller `BookingController`, which contains no logic for now, as the controllers for the two directives implement the required functionality.

Whenever the user changes the current section, the list of available tickets is updated; this logic is implemented by the `TicketsController` controller bound to the `addTickets` directive. Whenever the user adds the tickets to the booking, the booking summary is re-rendered this logic is implemented by the `CheckoutController` controller bound to the `checkoutBooking` directive. Changes in quantities or the target email may enable or disable the submission button - the booking is validated whenever changes to it are made. We do not create separate modules for the directives, since they are not referenced outside the module.

The booking submission is handled by the `checkout` method in the `CheckoutController` which constructs a JSON object, as required by a POST to `http://localhost:8080/ticket-monster/rest/bookings`, and performs the AJAX call. In case of a successful response, a confirmation view is rendered. On failure, a warning is displayed and the user may continue to edit the form.

It should be noted that logic to encapsulate the shopping cart is extracted out into a separate AngularJS service - `ShoppingCart`. This state of the shopping cart is shared among the controllers, and it is recommended to share such state across controllers through a service.

The corresponding templates for the directives above are shown below:

.src/main/webapp/resources/js/app/booking/add-tickets.html
[source,html]
-------------------------------------------------------------------------------------------------------
<div class="col-md-4">
    <div class="well">
        <h3 class="page-header">Select tickets</h3>
        <form class="form-horizontal">
            <div id="sectionSelectorPlaceholder">
                <div class="form-group">
                    <label class="col-md-3 control-label" for="sectionSelect"><strong>Section</strong></label>
                    <div class="col-md-9">
                        <select id="sectionSelect" class="form-control" ng-options="section as (section.name + ' - ' + section.description) for section in sections" ng-model="selectedSection">
                            <option value="">Choose a section</option>
                        </select>
                    </div>
                </div>
            </div>
        </form>
        <div id="ticketCategoriesViewPlaceholder">
            <form class="form-horizontal" ng-if="ticketPrices.length > 0">
                <div ng-repeat="ticketPrice in ticketPrices" class="form-group" id="ticket-category-fieldset-{{ticketPrice.id}}">
                    <label class="col-md-3 control-label"><strong>{{ticketPrice.ticketCategory.description}}</strong></label>

                    <div class="col-md-9">
                        <div class="input-group">
                            <input class="form-control col-md-6" rel="tooltip" title="Enter value"
                                   data-tm-id="{{ticketPrice.id}}"
                                   placeholder="Number of tickets"
                                   name="tickets-{{ticketPrice.ticketCategory.id}}" type="number" min="0" ng-model="ticketPrice.quantity" />
                            <span class="input-group-addon">@ ${{ticketPrice.price}}</span>

                            <p class="help-block" id="error-input-{{ticketPrice.id}}"></p>
                        </div>
                    </div>
                </div>

                <p>&nbsp;</p>

                <div class="form-group">
                    <div class="col-md-offset-2">
                        <input type="button" class="btn btn-primary visible-md-inline visible-lg-inline" ng-disabled="checkTickets()" ng-click="addTickets()" name="add" value="Add tickets"/>
                    </div>
                </div>
            </form>
        </div>
    </div>
</div>
-------------------------------------------------------------------------------------------------------

.src/main/webapp/resources/js/app/booking/checkout-booking.html
[source,html]
-------------------------------------------------------------------------------------------------------
<div id="request-summary" class="col-md-5 col-md-offset-1">
    <div class="well">
        <h3 class="page-header">Order summary</h3>
        <div id="ticketSummaryView" class="row">
            <div class="col-md-12">
                <div ng-show="tickets.length > 0" class="table-stack">
                    <table class="table table-bordered table-striped table-condensed" style="background-color: #fffffa;">
                        <thead>
                        <tr>
                            <th colspan="7"><strong>Requested tickets</strong></th>
                        </tr>
                        <tr>
                            <th>Section</th>
                            <th>Category</th>
                            <th>Quantity</th>
                            <th>Price</th>
                            <th></th>
                        </tr>
                        </thead>
                        <tbody id="ticketRequestSummary" ng-repeat="ticketRequest in tickets">
                        <tr>
                            <td data-title="Section">{{ticketRequest.ticketPrice.section.name}}</td>
                            <td data-title="Category">{{ticketRequest.ticketPrice.ticketCategory.description}}</td>
                            <td data-title="Quantity">{{ticketRequest.quantity}}</td>
                            <td data-title="Price">{{ticketRequest.ticketPrice.price}}</td>
                            <td><span class="glyphicon glyphicon-trash" ng-click="removeTicket($index)" /></td>
                        </tr>
                        </tbody>
                    </table>
                    <p/>
                    <div class="row">
                        <div class="col-md-5"><strong>Total ticket count:</strong> {{totals.tickets}}</div>
                        <div class="col-md-5"><strong>Total price:</strong> ${{totals.price}}</div>
                    </div>
                </div>
                <div ng-show="tickets.length == 0">
                    <p>
                        No tickets requested.
                    </p>
                </div>
            </div>
        </div>
        <h3 class="page-header">Checkout</h3>
        <div class="row">
            <div class="col-md-12">
                <form name="submitForm">
                    <div class="form-group">
                        <input ng-model="bookingRequest.email" type='email' id="email" name="email" class="form-control" placeholder="Email" required/>
                        <p class="help-block error-notification" id="error-email" ng-show="submitForm.email.$invalid && !submitForm.email.$pristine">Please enter a valid e-mail address</p>
                    </div>
                    <div class="form-group visible-md-block visible-lg-block">
                        <input type='button' class="btn btn-primary" name="submit" value="Checkout"
                               ng-disabled="enableCheckout()" ng-click="checkout()" />
                    </div>
                </form>
            </div>
        </div>
    </div>
</div>
-------------------------------------------------------------------------------------------------------

The Booking page holding the two components is:

.src/main/webapp/resources/js/app/booking/booking.html
[source,html]
-------------------------------------------------------------------------------------------------------
<div class="row">
    <div class="col-md-12">
        <h2 class="special-title light-font">{{show.event.name}}
            <small>{{show.venue.name}}, {{performance.date | date : "EEE d MMMM yyyy 'at' h:mma"}}</p></small>
        </h2>
    </div>
</div>
<div class="row">
    <div>
        <div add-tickets />
        <div checkout-booking />
    </div>
</div>
-------------------------------------------------------------------------------------------------------

Finally, once the module is complete, we can add it to the aggregator:

.src/main/webapp/resources/js/app/aggregator/desktop.js
[source, javascript]
-------------------------------------------------------------------------------------------------------
'use strict';

/**
 * The main module for the desktop application.
 * Pulls in other modules.
 */
define("aggregator", [
    'angular',
    'angularRoute',
    'angularResource',
    'app/home/view',
	'app/events/eventsView',
	'app/eventDetail/eventDetailView'
],function (angular) {

    return angular.module('ticketMonster', ['ngRoute',
        'ngResource',
		'ticketMonster.api',
        'ticketMonster.homeView',
		'ticketMonster.eventsView',
		'ticketMonster.eventDetailView'])
        .config(['$routeProvider', function($routeProvider) {
            $routeProvider
                .otherwise({redirectTo: '/'});
        }]);
});
-------------------------------------------------------------------------------------------------------

This concludes the implementation of the booking use case. We started by listing the available events, continued by selecting a venue and performance time, and ended by choosing tickets and completing the order.

The other use cases: a booking starting from venues and view existing bookings are conceptually similar, so you can just add the modules for the following routes from `src/main/webapp/resources/js/app/aggregator/desktop.js`:

* `venues`
* `venues/:id`
* `bookings`
* `bookings/:id`

Finally, copy the following files in the `src/main/webapp/resources/js/app/venues`, `src/main/webapp/resources/js/app/venueDetail` and 
`src/main/webapp/resources/js/app/booking` :

* `src/main/webapp/resources/js/app/venues/venues.html`
* `src/main/webapp/resources/js/app/venues/venuesView.js`
* `src/main/webapp/resources/js/app/venueDetail/venueDetail.html`
* `src/main/webapp/resources/js/app/venueDetail/venueDetailView.js`
* `src/main/webapp/resources/js/app/booking/booking-list.htnl`
* `src/main/webapp/resources/js/app/booking/booking-detail.htnl`
* `src/main/webapp/resources/js/app/booking/view.js`


== Mobile view


The mobile version of the application uses approximately the same architecture as the desktop version. Any differences are due to the functional changes in the mobile version and the use of responsive styles. 

=== Setting up the structure

For mobile clients, the main page will display the mobile version of the application, by loading the mobile AMD module of the application. Let us create it.

.src/main/webapp/resources/js/configurations/mobile.js
[source,javascript]
-------------------------------------------------------------------------------------------------------
/**
 * Shortcut alias definitions - will come in handy when declaring dependencies
 * Also, they allow you to keep the code free of any knowledge about library
 * locations and versions
 */
require.config({
    baseUrl:"resources/js",
    paths: {
        jquery:'libs/jquery-2.1.1',
        underscore:'libs/underscore',
        text:'libs/text',
        bootstrap: 'libs/bootstrap',
        angular: 'libs/angular',
        angularRoute: 'libs/angular-route',
        angularResource: 'libs/angular-resource',
        angularTouch: 'libs/angular-touch',
        aggregator: 'app/aggregator/mobile'
    },
    // We shim Angular and Underscore.js since they don't declare AMD modules
    shim: {
        'angular': {'exports' : 'angular'},

        'angularRoute': {
            deps: ['angular']
        },

        'angularResource': {
            deps: ['angular']
        },

        'angularTouch': {
            deps: ['angular']
        },

        'underscore': {
            exports: '_'
        }
    },
    priority: [
        "angular"
    ]
});

define("configuration", function() {
    if (window.TicketMonster != undefined && TicketMonster.config != undefined) {
        return {
            baseUrl: TicketMonster.config.baseRESTUrl
        };
    } else {
        return {
            baseUrl: ""
        };
    }
});

// Now we declare all the dependencies
// This loads and runs the 'initializer' and 'aggregator' modules.
require([
        'jquery',
        'angular',
        'aggregator'
    ], function($, angular, app) {
        // Configure jQuery to append timestamps to requests, to bypass browser caches
        // Important for MSIE
        $.ajaxSetup({cache:false});
        $('head').append('<link rel="stylesheet" href="resources/css/bootstrap.css" type="text/css" media="all"/>');
        $('head').append('<link rel="stylesheet" href="resources/css/bootstrap-theme.css" type="text/css" media="all"/>');
        $('head').append('<link rel="stylesheet" href="resources/css/screen.css" type="text/css" media="all"/>');

        $.ajax({
            url:'resources/js/app/aggregator/main.html',
            type: "GET",
            success: function(data) {
                $('body').append(data);
                angular.element().ready(function() {
                    // bootstrap the app manually
                    angular.bootstrap(document, ['ticketMonster']);
                });
            }
        });
    }
);
-------------------------------------------------------------------------------------------------------

In this application, we add touch support through the `ngTouch` AngularJS module to add touch support, while retaining the other modules.

[TIP]
.ngTouch
========================================================================
The `ngClick` directive supplied by `ngTouch` replaces the default ngClick directive provided by AngularJS.
For mobile browsers, this is essential as they wait 300ms after a tap, to determine whether a click event must be sent to the JavaScript engine.
The `ngClick` directive from `ngTouch` handles the tap immediately, and then prevents the following click event from propagating.
========================================================================

Like in the desktop application, the module loads all the utility libraries, converting them to AMD modules where necessary (like it is the case for Angular and Underscore). It also defines a separate module - the `configuration` module that allows customizing the REST service URLs. The `configuration` module does not play any role in the mobile web version. We will come to it, however, when discussing hybrid applications. Finally, it loads the dependent modules - `jquery`, `bootstrap` and `aggregator`.

Next, we create the aggregator module for the mobile application.

.src/main/webapp/resources/js/app/aggregator/mobile.js
[source,javascript]
-------------------------------------------------------------------------------------------------------
'use strict';

/**
 * A module for the aggregator of the desktop application
 */
define("aggregator", [
    'angular',
    'angularRoute',
    'angularResource',
    'angularTouch',
    'app/home/view',
    'app/events/eventsView',
    'app/venues/venuesView',
    'app/eventDetail/eventDetailView',
    'app/venueDetail/venueDetailView',
    'app/booking/view'
],function (angular) {

    return angular.module('ticketMonster', ['ngRoute',
        'ngResource',
        'ngTouch',
        'ticketMonster.api',
        'ticketMonster.homeView',
        'ticketMonster.eventsView',
        'ticketMonster.venuesView',
        'ticketMonster.eventDetailView',
        'ticketMonster.venueDetailView',
        'ticketMonster.bookingView'])
        .config(['$routeProvider', function($routeProvider) {
            $routeProvider
                .otherwise({redirectTo: '/'});
        }]);
});
-------------------------------------------------------------------------------------------------------

This is no different from the desktop application, except for declaring `ngTouch` as a dependent module.

=== Adding responsiveness

Most of the AngularJS partials already use responsive styles to automatically display content for medium and large size screens, and automatically reflow them for mobile and tablet sized screens as defined by the BootStrap grid system. Some content is also hidden on mobile devices as they are too large to display. For instance, the BootStrap carousel component is hidden on smaller form-factors:

.src/main/webapp/resources/js/app/events/events.html
[source,html]
-------------------------------------------------------------------------------------------------------
<div class="row">
    <div class="col-md-3 col-md-offset-1">
        <div class="panel" id="itemMenu">

            <div class="panel panel-default" ng-repeat="category in categories">
                <div class="panel-heading">
                    <a class="panel-toggle"
                       data-target="#category-{{category.id}}-collapsible" data-toggle="collapse"
                       data-parent="#itemMenu">{{category.description}}</a>
                </div>
                <div id="category-{{category.id}}-collapsible" class="panel-collapse collapse">
                    <div id="category-{{category.id}}" class="panel-body">
                        <p ng-repeat="event in events" ng-if="event.category.id == category.id">
                            <a menu-popover href="#events/{{event.id}}" rel="popover"
                              data-content="{{event.description}}"
                              data-original-title="{{event.name}}">{{event.name}}</a>
                        </p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id='itemSummary' class="col-md-8 hidden-xs">
        <div class="carousel-container">
            <div id="eventCarousel" class="carousel slide">
			
                ...
            
			</div>
        </div>
    </div>
</div>
-------------------------------------------------------------------------------------------------------

Note the use of the `hidden-xs` style on the `itemSummary` element. The use of this BootStrap style ensures the carousel is hidden on smaller devices.

We also need to handle component interactions that are not mobile-friendly. In desktop-sized screens, there is sufficient space to display BootStrap popovers when hovering over the name of the event or venue. The `hover` event does not exist for touch-style devices, and thus, we need to disable the display of popovers on hover, for such devices:

.src/main/webapp/resources/js/app/components/components.js
[source,html]
-------------------------------------------------------------------------------------------------------
'use strict';
define([
    'angular',
    'bootstrap'
], function (angular) {
    angular.module('ticketMonster.ui.components',[])
        .directive('menuPopover', function () {
            return {
                restrict: 'A',
                template: '',
                link: function (scope, el, attrs) {
                    if (!Modernizr.touch) {
                        $(el).popover({
                            trigger: 'hover',
                            container: '#content',
                            content: attrs.content,
                            title: attrs.originalTitle
                        }).data('bs.popover')
                            .tip()
                            .addClass('visible-lg')
                            .addClass('visible-md');
                    }
                }
            };
        });
});
-------------------------------------------------------------------------------------------------------

The `menuPopover` directive ensures the BootStrap popover component is not activated if `Modernizr.touch` is true, i.e. a touch screen device is detected in the environment.

Most requirements for responsive design are simple enough to achieve through the use of BootStrap's styles. However, the booking page needs to be handled differently. For mobile and tablet screens, we will opt to show the component to add tickets in one view. On adding tickets to the cart, we will switch to another view to display the cart. Additionally, we'll re-orient the action buttons to display them in a footer. In order to achieve this, we will add logic to toggle the components being displayed:

The Booking page holding the two components is:

.src/main/webapp/resources/js/app/booking/booking.html
[source,html]
-------------------------------------------------------------------------------------------------------
<div class="row">
    <div class="col-md-12">
        <h2 class="special-title light-font">{{show.event.name}}
            <small>{{show.venue.name}}, {{performance.date | date : "EEE d MMMM yyyy 'at' h:mma"}}</p></small>
        </h2>
    </div>
</div>
<div class="row">
    <div class="visible-md-block visible-lg-block">
        <div add-tickets />
        <div checkout-booking />
    </div>
    <div class="visible-xs-block visible-sm-block">
        <div ng-show="displayView" add-tickets>
        </div>
        <div ng-show="!displayView" checkout-booking>
        </div>
    </div>
</div>
<footer class="mobile-footer visible-xs-block visible-sm-block">
    <div class="container" ng-show="displayView">
        <div id="ticketFooter" class="row top4">
            <div class="col-xs-6">
                <input type="button" class="btn btn-primary" ng-disabled="checkTickets()" ng-click="addTickets()" name="add" value="Add tickets"/>
            </div>
            <div class="col-xs-6">
                <input type="button" class="btn btn-primary" ng-disabled="disableToggle()" ng-click="toggleView()" name="add" value="Checkout" />
            </div>
        </div>
    </div>
    <div class="container" ng-show="!displayView">
        <div id="checkoutFooter" class="row top4">
            <div class="col-xs-6">
                <input type="button" class="btn btn-primary" ng-click="toggleView()" name="add" value="Add more tickets"/>
            </div>
            <div class="col-xs-6">
                <input type='button' class="btn btn-primary" name="submit" value="Checkout"
                       ng-disabled="disableCheckout()" ng-click="checkout()" />
            </div>
        </div>
    </div>
</footer>
-------------------------------------------------------------------------------------------------------

In the modified partial, note the use of `visible-md-block` and `visible-lg-block` BootStrap styles to display both the `add-tickets` and `checkout-booking` components for medium and large screens. Additionally, the `visible-xs-block` and `visible-sm-block` styles are used to display the `add-tickets` and `checkout-booking` components based on the state of a toggle variable `displayView`. The compoents are thus activated twice, but displayed only once, depending on the size of the screen. On changing the size of the screen, the contents automatically update themselves to show the desktop or mobile equivalent, without requiring the `resize` event to be handled. This is made easy by having both components store the state in a shared Angular service.

The logic to toggle the displayed component in mobile views, is present in the `BookingController`:

.src/main/webapp/resources/js/app/booking/view.js
[source,javascript]
-------------------------------------------------------------------------------------------------------
'use strict';
define([
    'angular',
    'underscore',
    'configuration',
    'angularRoute',
    'app/api/services'
], function(angular, _, config) {
    angular.module('ticketMonster.bookingView', ['ngRoute', 'ticketMonster.api'])
	
	...
	.controller('BookingController', ['$scope', '$routeParams', '$location', 'BookingService', function($scope, $routeParams, $location, BookingService) {
	            $scope.toggleView = function() {
	                $scope.displayView = !$scope.displayView;
	            };

	            $scope.disableToggle = function() {
	                return BookingService.isEmpty();
	            };

	            $scope.displayView = true;
	        }])
	...
});
-------------------------------------------------------------------------------------------------------

When tickets are added to the cart, the view is toggled to display the cart, in the `addTickets` function :

.src/main/webapp/resources/js/app/booking/view.js
[source,javascript]
-------------------------------------------------------------------------------------------------------
'use strict';
define([
    'angular',
    'underscore',
    'configuration',
    'angularRoute',
    'app/api/services'
], function(angular, _, config) {
    angular.module('ticketMonster.bookingView', ['ngRoute', 'ticketMonster.api'])
	
	...
	.controller('TicketsController', ['$scope', '$routeParams', '$location', 'BookingService', 'ShowResource', 'BookingResource', function($scope, $routeParams, $location, BookingService, ShowResource, BookingResource) {
	            ...

	            $scope.addTickets = function() {
	                _.each($scope.ticketPrices, function (ticketPrice) {
	                    if (ticketPrice.quantity != undefined) {
	                        BookingService.addTicket(ticketPrice);
	                    }
	                });
	                $scope.selectedSection = null;
	                $scope.toggleView();
	            };
				
				...
				}])
	...
});
-------------------------------------------------------------------------------------------------------

Similarly, if the "Add Tickets" button in the cart view is clicked, or if the "Checkout" button in the Ticket summary view is clicked. the view is toggled back to the other view:

.src/main/webapp/resources/js/app/booking/bboking.html
[source,html]
-------------------------------------------------------------------------------------------------------
<div class="row">
...
</div>
<footer class="mobile-footer visible-xs-block visible-sm-block">
    <div class="container" ng-show="displayView">
        <div id="ticketFooter" class="row top4">
            ...
            <div class="col-xs-6">
                <input type="button" class="btn btn-primary" ng-disabled="disableToggle()" ng-click="toggleView()" name="add" value="Checkout" />
            </div>
        </div>
    </div>
    <div class="container" ng-show="!displayView">
        <div id="checkoutFooter" class="row top4">
            <div class="col-xs-6">
                <input type="button" class="btn btn-primary" ng-click="toggleView()" name="add" value="Add more tickets"/>
            </div>
            ...
        </div>
    </div>
</footer>
-------------------------------------------------------------------------------------------------------


Through the use of responsive styles and conditional loading of the `ngTouch` module, we have created a responsive application that works on both desktop and mobile devices.